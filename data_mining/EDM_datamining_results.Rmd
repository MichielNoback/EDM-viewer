---
title: "EDM-results"
author: "RWedema"
date: "8-3-2021"
output:
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: no
  pdf_document:
    toc: yes
    toc_depth: '3'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, cache = TRUE)
```

# Abstract


# Introduction
Many chronic inflammatory diseases, including asthma, atherosclerosis, and cancer can be linked to defects in the directional movements of cells. This process of movement is called chemotaxis and it plays an important role in sensing, migrating, and moving towards extracellular stimuli and finally engulfing of these external targets[1]. To facilitate this process, the cell must undergo dynamic regulation of the cytoskeleton. Cellular processes such as phagocytosis (eating), macropinocytosis (drinking), and chemotaxis (moving) can share underlying molecular pathways, and competition between these pathways can occur. The effect of this competition is that while a cell is heavily involved in pinocytosis, resources are limited and chemotoxis is performed less efficiently, and the opposite is also true, cells that are moving are limited in eating[2]. Mechanisms that control the switching between the different states are poorly understood.

The slime mold *Dictyostelium*, a model organism for studying chemotaxis is used in this research as it shares the key pathways regulating eating, drinking, and moving with humans[3].

In previous research, *Dictyostelium* has been used to create mutants that still have the minimal requirement to perform chemotaxis[4]. A basal signaling module has been identified that activates the proteins Ras and F-actin via a signaling cascade involving associated heterotrimeric G-proteins and Rac[5]. Actin polymerization takes place at the leading edge of the cell and acto-myosin at the rear and sides of the cell. Through inhibition of the pseudopod formation at the rear (retracting the cell) and inducing the formation of local pseudo-podia using the actin filaments, cell movements are controlled. Cytoskeletal rearrangements in eating, drinking, and moving all share the Ras and Rac monomeric G-proteins suggesting a key role in switching between the different states.

To research the underlying molecular mechanisms involved, an integrated approach will be taken, multiple datasets will be combined into a knowledge database that can be used to query components involved in regulating chemotaxis. Over 20 different *Dictyostelium* and neutrophils G-proteins have been used as bait in pull-down proteomics experiments under different conditions. These datasets together with the publicly available gene expression datasets (www.dictybase.org) and functional protein descriptions extracted from scientific literature will form the basis of the knowledge database. By using statistical methods suited for big data such as machine learning (text mining in particular[6 7]) with the combination of the datasets in the knowledge database, new biological observations can be made. 

The research can be divided into several research questions/outcomes:
1.	Combining data islands: data from the different sources will be reformatted, combined, and annotated into a single database with a common vocabulary such that a single integrated analysis can be performed. Data will be made available with FAIR (Findable, Accessible, Interpretable, Reusable) principles. For this we will use the R Shiny framework.
2.	Disentanglement of the biological pathways related to eating, drinking, and moving: the R BioConductor project that contains many tools for the analysis of data generated by wet-lab experiments together with univariate statistics and multivariate analysis will be used to identify the proteins that are switched on during all activities as these provide the basic machinery for these processes. A similar analysis will also be performed for the identification of key proteins for eating, drinking, and moving separately by looking for proteins that are uniquely expressed during one condition.
3.	Confirm core identified set of proteins: a literature text mining approach will be used on the identified key proteins from the previous step against the available scientific literature to elucidate their role in the processes. For this we will use an existing database in which more than half a million keywords describing genes, metabolites, pathways and diseases have been mapped to the entire MEDLINE database. 
4.	Identify novel proteins involved in the process: network cluster-analysis will be used to identify other proteins involved in the process. This can be accomplished by looking for proteins that have an indirect relationship using an ABC principle, in such principle, there is no direct relation between A and C, however, an indirect relationship through an intermediate B could be predicted.


# Materials and Methods
```{r, echo=FALSE, warning=FALSE, message=FALSE}
# load saved annotated dicty dataframe with baits, spectral counts, z-scores and GO-terms
load("all_data_dicty_annotated.RData")

source("data_processing.R")
source("../utils/visualization_functions.R")

library(RVenn)
library(tidyverse)
library(ggplot2)
library(factoextra)
library(igraph)
library(visNetwork)
library(ggplot2)
library(scales)
library(pheatmap)
library(rafalib)
library(clusterProfiler)
library(GOSemSim)
library(AnnotationHub)
library(GOsummaries)
library(RColorBrewer)
library(purrr)
library(reshape2)
```

**TODO explain the experiments performed used and baits used**
```{r}
knitr::kable(unique(all_data_dicty$bait), caption = "Baits used.", col.names = c("Baits"))
```


Gbeta1 and Gbeta2 are replicates

RapA_normal and RapA_control are replicates (although different conditions?)

Galpha2 and 4 perform the same function

Galpha4 eating + moving

Galpha8 only moving

Galpha1

Galpha2 (http://dictybase.org/gene/DDB_G0276267)

Roco4 is for background corrections


**Normal, control (replicate), starvation, background (ROCO4)**

Raw ms-spec data was exported from Scaffold4 using the the following settings: 99.0% percent Protein Threshold, minimum number of Peptides 2 and Peptide Threshold was set at 95%. 



# Results

```{r}
# unique(all_data_dicty$Organism)
#[1] NA                                      "Dictyostelium discoideum (Slime mold)" "Sus scrofa (Pig)"                     
#[4] "Homo sapiens (Human)"                  "Escherichia coli (strain K12)"         "NA"                                   
#[7] "Coremiostelium polycephalum"           "Cavenderia fasciculata"                "Dictyostelium citrinum (Slime mold)" 

#Coremiostelium polycephalum and Cavenderia fasciculata are both Dictyostelium

#all_data_dicty$uniprot[all_data_dicty$Organism == "NA"]
# 187 without organism annotation, including the 32 mentioned above (NA)
#187 - 32 have annotation like: "sp|P18624|EF1A_DICDI" 
#na_organism <- all_data_dicty$uniprot[all_data_dicty$Organism == "NA"]


# annotate the missing organism use uniprot identifier to get the organism
all_data_dicty$Organism <- apply(all_data_dicty, MARGIN = 1, get_organism)

all_data_non_corrected <- all_data_dicty

# remove GST tag?
all_data <- all_data_dicty %>% 
  filter(uniprot != "GST")

# get all non Dicty species
all_data_non_dicty <- all_data %>% 
  filter(!Organism  %in% c("Dictyostelium discoideum (Slime mold)", "Coremiostelium polycephalum", "Dictyostelium citrinum (Slime mold)", "Cavenderia fasciculata"))

# filter only the Dicty species
all_data_dicty <- all_data %>%
  filter(Organism %in% c("Dictyostelium discoideum (Slime mold)", "Coremiostelium polycephalum", "Dictyostelium citrinum (Slime mold)", "Cavenderia fasciculata"))


#select all proteins that have a interaction with roco4 above threshold
roco4_uniprot_dicty <- all_data %>% 
    filter(bait=='Roco4') %>% 
    dplyr::select(uniprot, z_score_spectral) %>%
    filter(z_score_spectral > 2 | z_score_spectral < -2)

# select all proteins that are not shared with roco4
all_data_dicty_roco4_corrected <- all_data_dicty %>% 
  filter(!(uniprot %in% roco4_uniprot_dicty$uniprot)) %>%
  filter(!bait == "Roco4")

```

The number of uniquely expressed proteins over all experiments
```{r}
length(unique(all_data_dicty_roco4_corrected$uniprot))
```

```{r, echo=FALSE, results=FALSE}
# show the counts per organism after removal of other species, see supplement for counts before removal
knitr::kable(all_data_dicty_roco4_corrected %>% 
               group_by(Organism) %>% 
               summarise(Unique_Proteins = n_distinct(uniprot)), 
             caption = "Unique proteins per organism")

# Cavenderia fasciculata, same clade -> cellular organisms; Eukaryota; Amoebozoa; Evosea; Eumycetozoa; Dictyostelia; Acytosteliales; Cavenderiaceae; Cavenderia
# Coremiostelium polycephalum	, same order -> cellular organisms; Eukaryota; Amoebozoa; Evosea; Eumycetozoa; Dictyostelia; Dictyosteliales; Coremiostelium
# Dictyostelium citrinum (Slime mold -> same genus -> cellular organisms; Eukaryota; Amoebozoa; Evosea; Eumycetozoa; Dictyostelia; Dictyosteliales; Dictyosteliaceae; Dictyostelium
# Dictyostelium discoideum -> cellular organisms; Eukaryota; Amoebozoa; Evosea; Eumycetozoa; Dictyostelia; Dictyosteliales; Dictyosteliaceae; Dictyostelium
```


```{r}
# show uniq peptides for each experiments as bait can be part of multiple experiments this is on the filtered (on organism and GST tag) and background corrected proteins

uniq_uniprot_per_experiment <- all_data_dicty_roco4_corrected %>% 
  filter(spectral_count > 0) %>%
  group_by(bait, condition) %>%
  dplyr::summarise(unique_proteins = n_distinct(uniprot)) %>%
  tidyr::unite(Experiment, c(bait, condition), sep = "_")

knitr::kable(uniq_uniprot_per_experiment, caption = "Unique proteins per experiment after filtering on species and roco4 background correction")
```

Barplot showing the number of uniquely expressed proteins per experiment
```{r}

uniq_uniprot_per_experiment %>%
  mutate(experiment = fct_rev(Experiment)) %>%
  ggplot(aes(x=experiment,y=unique_proteins)) +
  geom_bar(stat="identity", fill="steelblue") +
  labs(title="Background compared unique interacting proteins per experiment") + 
  geom_text(aes(label=unique_proteins), hjust=1.6, color="white", size=3.5) +
  theme() +
  coord_flip() +
  scale_x_discrete()

```


## Experiment correlation on filtered dicty spectral count data with Roco4 background correction
```{r}
# correlate count per peptide over the experiments
cor_experiment_fun <- function(my_data){
  cor_experiment <- my_data %>% 
  group_by(bait, condition) %>%
  dplyr::select(uniprot, bait, condition, spectral_count) %>%
  dplyr::mutate(row = row_number()) %>%
  tidyr::pivot_wider(names_from = uniprot, values_from = spectral_count, values_fill = 0) %>%
  dplyr::select(-row) %>%
  summarise_all(list(sum = sum)) %>%
  tidyr::unite(bait_condition, c(bait, condition), sep = "_") %>% 
  tibble::column_to_rownames(var = "bait_condition")
  
  return(cor_experiment)
}
```


```{r}
cor_experiment_roco4_corrected_dicty <- cor_experiment_fun(all_data_dicty_roco4_corrected)
  
pivoted_experiment_t_roco4_corrected_dicty <- t(cor_experiment_roco4_corrected_dicty)
res_t_pivoted_experiment_roco4_corrected_dicty <- cor(pivoted_experiment_t_roco4_corrected_dicty)
```


```{r}
#heatmap(x = res_t_pivoted_experiment_roco4_corrected_dicty, symm = TRUE, main = "Roco4 corrected spectral counts using dicty proteins")
pheatmap(mat = res_t_pivoted_experiment_roco4_corrected_dicty, fontsize_row = 10, main = "Roco4 corrected spectral counts using dicty proteins", angle_col = 45)
```


## Experiment correlation on filtered dicty spectral count data with Roco4 background correction, No Replicates or Mutants
```{r}

# take subset removing the starv, control, mutant and Gbeta2 (replicate)  
normal_experiments_sub <- all_data_dicty_roco4_corrected %>% 
  filter(condition != "starv") %>%
  filter(condition != "control") %>%
  filter(bait != "RasG-S17N") %>%
  filter(bait != "Gbeta2")


cor_experiment_roco4_corrected_dicty_normal_experiments <- cor_experiment_fun(normal_experiments_sub)
  
pivoted_experiment_t_roco4_corrected_dicty_normal <- t(cor_experiment_roco4_corrected_dicty_normal_experiments)
res_t_pivoted_experiment_roco4_corrected_dicty_normal <- cor(pivoted_experiment_t_roco4_corrected_dicty_normal)

new_names <- str_replace(rownames(res_t_pivoted_experiment_roco4_corrected_dicty_normal), pattern = "_normal", replacement = "")

rownames(res_t_pivoted_experiment_roco4_corrected_dicty_normal) <- new_names
colnames(res_t_pivoted_experiment_roco4_corrected_dicty_normal) <- new_names

pheatmap(mat = res_t_pivoted_experiment_roco4_corrected_dicty_normal, fontsize_row = 10, main = "Correlation on normal condition experiments", angle_col = 45)
```



## PCA Experiment on z_score_spectral background corrected
```{r}
my_data <- all_data_dicty_roco4_corrected %>%
  group_by(bait, condition) %>% 
  tidyr::unite(bait_condition, c(bait, condition), sep = "_")

# want to select uniprot short here for later plots, instead of the long uniprot id
pca_experiment_roco4_corrected <- my_data %>% 
  dplyr::select(uniprot, bait_condition, z_score_spectral) %>%
  group_by(bait_condition) %>%
  pivot_wider(names_from = uniprot, values_from = z_score_spectral, values_fill = 0) %>%
  summarise_all(list(sum = sum)) %>%
  tibble::remove_rownames() %>%
  tibble::column_to_rownames(var = "bait_condition") 


#rownames(wdbc.pr_roco4_corrected$rotation)[302]
#[1] "rsp|P07395|SYFB_ECOLI_sum"
#rownames(wdbc.pr_roco4_corrected$rotation)[933]
#[1] "sp|P07395|SYFB_ECOLI_sum"

#Both are short P07395, giving non uniq warnings when changing to short_uniprot annotation

# get shorter identifiers, see above why we are not returning the uniprot id only, fixed by keeping sp or tr in the id, i.e. -> tr|Q86B07"
df <- data_frame("names" = colnames(pca_experiment_roco4_corrected))
df$names <- stringr::str_split(df$names, "\\|")
colnames(pca_experiment_roco4_corrected) <- as.character(lapply(df$names, function(l) paste(l[1:2], collapse = "|")))


wdbc.pr_roco4_corrected <- prcomp(pca_experiment_roco4_corrected)
summary(wdbc.pr_roco4_corrected)
```


```{r}
fviz_pca_ind(wdbc.pr_roco4_corrected, geom = c("point", "text"), pointshape = 21, 
             pointsize = 2, 
             fill.ind = rownames(pca_experiment_roco4_corrected), 
             col.ind = "black", 
             palette = "ucscgb", 
            # addEllipses = TRUE,
             label = "all",
             col.var = "black",
             repel = TRUE,
             legend.title = "Experiments") +
  ggtitle("2D PCA-plot") +
  theme(plot.title = element_text(hjust = 0.5))
```


```{r fig.fullwidth=TRUE, paged.print=FALSE}
leading_genes <- wdbc.pr_roco4_corrected$rotation

# misleading, as the large contributers can also be at the bottom of the list -values!, when not sorted on absolute values -> need to sort absolute
leading_PC1 <- sort(abs(leading_genes[,1]), decreasing = T)
leading_PC2 <- sort(abs(leading_genes[,2]), decreasing = T)

leading_PC1_names <- names(leading_PC1[1:10])
leading_PC2_names <- names(leading_PC2[1:10])


mypar(1,2,mar=c(16,4,2,2))
fviz_contrib(wdbc.pr_roco4_corrected, choice = "var", axes = 1, top = 10)
fviz_contrib(wdbc.pr_roco4_corrected, choice = "var", axes = 2, top = 10)

#PC1 contrib of variables
#sp|P15064 = rasG
#tr|Q75JY8 = Uncharacterized, GO molecular -> actin filamen binding
#tr|Q553S7 = pccA; https://www.uniprot.org/uniprot/Q553S7 , GO Bio -> lipid catabolic, GO cellular component -> phagocytic vesicle
#sp|Q55FF3 = gsta1; https://www.uniprot.org/uniprot/Q55FF3 , GO cellular component -> phagocytic vesicle, Go mol -> glutathione transferase activity
#sp|Q6IMN8 = alrA; https://www.uniprot.org/uniprot/Q6IMN8 , GO cellular component -> phagocytic vesicle/cytosol,  GO biological process -> response to bacterium, negative regulation aggregate size in sorocarp development, cell motility
#sp|P54654 = cap; https://www.uniprot.org/uniprot/P54654, GO -> pino, mitotic cytokinese, actin polymerization, aggregation involved in sorocarp development, cell-cell adhesion, morphogenesis, contractile vacuole organization, cell polarity, and more
#sp|P42528 = arpC; https://www.uniprot.org/uniprot/P42528, GO -> actin filamenr binding, atp binding, exo-phagocytose, + regulation of actin filament polymerization, response to bacterium, pseudopodium/cytocol/cytoskeleton/cell cortex
#sp|P10733 = seva; https://www.uniprot.org/uniprot/P10733, GO -> actin filament binding, actin cytoskeleton, cytoplasm, phagocytic vesicle
#sp|Q54SF7 = aatB, https://www.uniprot.org/uniprot/Q54SF7, amino acid metabolism, 
#sp|Q54KM7 = gcvP; https://www.uniprot.org/uniprot/Q54KM7, GO -> mitochondrion, glycine binding

#TODO; get this in a nice table with annotation



#PC2 contrib of variables
#tr|Q54DU0; https://www.uniprot.org/uniprot/Q54DU0, uncharacterized, GO -> galpha subunit binding
#sp|P16051 = gpaB; https://www.uniprot.org/uniprot/P16051, G-protein, RAS/RAP regulating factor, GO -> Gprotein beta/gamma complex binding,  
#sp|Q75JD5 = pckA; https://www.uniprot.org/uniprot/Q75JD5, GO -> gluconeogenesis pathway, cytocol/phagocytic vesicle
#sp|P15064 = rasG
#sp|P54680 = fimA; https://www.uniprot.org/uniprot/P54680, GO -> actin binding, reproduction, cytoplasm/phagocytic cup/vesicle, leading edge, lameliipodium
#tr|Q54WL7 = uncharacterized; https://www.uniprot.org/uniprot/Q54WL7, GO ->fattyacid metabolic process, phagocytic vesicle
#tr|O76187 = darA; https://www.uniprot.org/uniprot/O76187, GO -> Rac GTPase binding, sorocarp development, cell migration, cell polarity, +regulation od GTPase activity, NOT essential for cytokineses/pino or phagocytoses or development, except in starvation
#sp|P18613 = rapA, https://www.uniprot.org/uniprot/P18613, Gprotein of the ras family, RAS related protein, GO -> -regulation macropinocytosis, RAS/Rap signal balancing in chemotaxis at leading edge of chemotaxing cells
#tr|Q54P24 = grfA ,https://www.uniprot.org/uniprot/Q54P24, GO -> regulation of sorocarp development, membrane, mitochondrium, cytoplasm
#sp|P54686 = aip1, https://www.uniprot.org/uniprot/P54686, actin depoly and polymerization, enhances chemotaxis actin assembly at leading edge, cell polarity, chemotaxis, phagocytosis, mitotic cleavage, reproduction, phacytic cup, lameliipodium, cell cortex
```


```{r}
#Plot of the individual contribution to the PCA dimensions
fviz_pca_var(wdbc.pr_roco4_corrected, geom = c("point", "text"), pointshape = 21, 
             pointsize = 4, 
             fill.var = rownames(t(pca_experiment_roco4_corrected)), 
             palette = "ucscgb", 
             label = "all",
             col.var = "black",
             repel = TRUE,
             select.var = list(contrib = 10),
             legend.title = "Proteins") +
  ggtitle("2D PCA-plot") +
  theme(plot.title = element_text(hjust = 0.5))

```

## PCA Experiment on z_score_spectral background corrected, No legend, Normal condition, No colour
```{r}
normal_experiments_sub <- all_data_dicty_roco4_corrected %>% 
  filter(condition != "starv") %>%
  filter(condition != "control") %>%
  filter(bait != "RasG-S17N") %>%
  filter(bait != "Gbeta2")

my_data <- normal_experiments_sub %>%
  group_by(bait, condition) %>% 
  tidyr::unite(bait_condition, c(bait, condition), sep = "_") %>%
  mutate(bait_condition = str_replace(bait_condition, pattern = "_normal", replacement = ""))

# want to select uniprot short here for later plots, instead of the long uniprot id
pca_experiment_roco4_corrected <- my_data %>% 
  dplyr::select(uniprot, bait_condition, z_score_spectral) %>%
  group_by(bait_condition) %>%
  pivot_wider(names_from = uniprot, values_from = z_score_spectral, values_fill = 0) %>%
  summarise_all(list(sum = sum)) %>%
  tibble::remove_rownames() %>%
  tibble::column_to_rownames(var = "bait_condition") 

df <- data_frame("names" = colnames(pca_experiment_roco4_corrected))
df$names <- stringr::str_split(df$names, "\\|")
colnames(pca_experiment_roco4_corrected) <- as.character(lapply(df$names, function(l) paste(l[1:2], collapse = "|")))

wdbc.pr_roco4_corrected <- prcomp(pca_experiment_roco4_corrected)
summary(wdbc.pr_roco4_corrected)

fviz_pca_ind(wdbc.pr_roco4_corrected, geom = c("point", "text"), pointshape = 21, 
             pointsize = 3, 
             #fill.ind = rownames(pca_experiment_roco4_corrected), 
             col.ind = "black", 
             palette = "ucscgb", 
            # addEllipses = TRUE,
             label = "all",
             col.var = "black",
             repel = TRUE,
             legend.title = "Experiments") +
  ggtitle("2D PCA-plot") +
  theme(plot.title = element_text(hjust = 0.5))
```
```{r}
#Plot of the individual contribution to the PCA dimensions, normal experiments only, no mutants
fviz_pca_var(wdbc.pr_roco4_corrected, geom = c("point", "text"), pointshape = 21, 
             pointsize = 4, 
             #fill.var = rownames(t(pca_experiment_roco4_corrected)), 
             palette = "ucscgb", 
             label = "all",
             col.var = "black",
             repel = TRUE,
             select.var = list(contrib = 10),
             legend.title = "Proteins") +
  ggtitle("2D PCA-plot on the individuals") +
  theme(plot.title = element_text(hjust = 0.5))

```


## GO term analysis on all experiments
```{r, echo=FALSE, message=FALSE}
experiments_GO_analysis <- list()

universe_accessions <- unique(all_data_dicty_roco4_corrected$uniprot_short)

# create new sub universe from total, filtering on the short uniprot ids in the current dataset
load(file = "UniverseGo.RData")
universeGO <- universeGO[rownames(universeGO) %in% universe_accessions,]

do_GO_analysis_on_experiments <- function(my_data = all_data_dicty_roco4_corrected_grouped, my_experiment = experiment){

  print(my_experiment)
  
  # filter on z-score, do we need to do this? as we are scoring all proteins?
  uniprot_ids <- all_data_dicty_roco4_corrected_grouped %>% 
    filter(experiment == my_experiment) %>%
    filter(z_score_spectral > 2 | z_score_spectral < -2) %>%
    select(uniprot)
  
  # convert ids long uniprot to short accession
  experiment_accessions <- get_uniprot(uniprot_ids)
  print(length(experiment_accessions))
  
  #Do enrichment analysis, report all proteins above z-score threshold
  MF_GO_phylo <- go_enrichment_analysis(accessions = experiment_accessions, ontology = "MF", tableTopNodes = length(experiment_accessions), save_file = TRUE, show_fig = FALSE, bait_condition = my_experiment)
  BP_GO_phylo <- go_enrichment_analysis(accessions = experiment_accessions, ontology = "BP", tableTopNodes = length(experiment_accessions), save_file = TRUE, show_fig = FALSE, bait_condition = my_experiment)
  CC_GO_phylo <- go_enrichment_analysis(accessions = experiment_accessions, ontology = "CC", tableTopNodes = length(experiment_accessions), save_file = TRUE, show_fig = FALSE, bait_condition = my_experiment)

  #select significant proteins
  #MF_GO_phylo <- MF_GO_phylo %>% filter(classicFisher <= 0.01)
  #BP_GO_phylo <- BP_GO_phylo %>% filter(classicFisher <= 0.01)
  #CC_GO_phylo <- CC_GO_phylo %>% filter(classicFisher <= 0.01)
  
  GO_list <- list("MF" = MF_GO_phylo, "BP" = BP_GO_phylo, "CC" = CC_GO_phylo)
 
  return(GO_list)
}

# group data on experiments
all_data_dicty_roco4_corrected_grouped <- all_data_dicty_roco4_corrected %>%
  group_by(bait, condition) %>% 
  tidyr::unite(experiment, c(bait, condition), sep = "_")

# get the unique experiment names
experiments <- unique(all_data_dicty_roco4_corrected_grouped$experiment)

# do go enrichment for each experiment, save results in list
for (experiment in experiments){
   experiments_GO_analysis[[experiment]] <- do_GO_analysis_on_experiments(my_data = all_data_dicty_roco4_corrected_grouped, my_experiment = experiment)
}


```

```{r}
# get Go term mapping
xx <- as.list(GOTERM)
```


```{r echo=FALSE}  
show_GO_heatmap_experiments <- function(level = NULL, Titel = "", sign = 0.01){
  MF_molten <- melt(level, id = c("GO.ID","classicFisher"))
  
  # get GO ids, instead Terms
  MF_molten_selected_ID <- MF_molten %>% 
    select(GO.ID, classicFisher, L1)
  
  MF_molten_selected_ID <- unique(MF_molten_selected_ID)
   
  MF_molten_pivot_ID <- t(pivot_wider(unique(MF_molten_selected_ID), names_from = L1, values_from = classicFisher))
  
  colnames(MF_molten_pivot_ID) <- MF_molten_pivot_ID[1,]
  MF_molten_pivot_ID <- MF_molten_pivot_ID[-c(1),]
  MF_molten_pivot_ID <- as.data.frame(MF_molten_pivot_ID)
  
  MF_molten_pivot_ID <- MF_molten_pivot_ID %>% 
    mutate(across(where(is.character), as.numeric)) %>% 
    select_if(~any(. <= sign)) %>%
    mutate_if(is.numeric, ~replace(., is.na(.), 1)) 
  
  Go2Term <- MF_molten %>% 
    filter(variable == "Term") %>%
    select(c(GO.ID, value))
  
  Go2Term <- unique(Go2Term)
  
  x <- xx[colnames(MF_molten_pivot_ID)]
  colnames(MF_molten_pivot_ID) <- as.character(map(x, Term))
  
  MF_molten_term_log10 <- -log10(t(MF_molten_pivot_ID))
  MF_molten_term_log10_ordered  <- MF_molten_term_log10[ order(rowMeans(MF_molten_term_log10), decreasing = T), ]
  
  pheatmap(mat = MF_molten_term_log10_ordered, fontsize_row = 8, main = Titel, angle_col = 45, cluster_rows = FALSE, cluster_cols = FALSE, cellwidth = 14, cellheight = 10)
  
  # Just for taking top .... for powerpoint
  #top10_MF_molten_term_log10_ordered <- MF_molten_term_log10_ordered[1:30,]
  #pheatmap(mat = top10_MF_molten_term_log10_ordered, fontsize_row = 10, main = Titel, angle_col = 45, cluster_rows = FALSE, cluster_cols = FALSE, cellwidth = 14, cellheight = 10)
  
  #return(MF_molten_term_log10_ordered)
  
}
```

```{r, fig.width=10, fig.retina=2}
# get first list (MF) of each experiment
MF <- map(experiments_GO_analysis, 1)

titel = "-log 10 p-values Fisher Test on GO Molecular Function level"
show_GO_heatmap_experiments(level = MF, Titel = titel, sign = 0.01)
```


```{r fig.width=10, fig.retina=1, out.width="650px", out.height="2400px"}
BP <- map(experiments_GO_analysis, 2, sign = 0.01)

titel = "-log 10 p-values Fisher Test on GO Biological Process level"
show_GO_heatmap_experiments(level = BP, Titel = titel, sign = 0.001)
```
## unique enriched GO terms all experiments
```{r fig.width=10, fig.retina=1}
# Filter on terms enriched in only 1 bait
BP <- map(experiments_GO_analysis, 2)
MF_molten <- melt(BP, id = c("GO.ID","classicFisher"))

# get GO ids, instead Terms
MF_molten_selected_ID <- MF_molten %>% 
  select(GO.ID, classicFisher, L1)

MF_molten_selected_ID <- unique(MF_molten_selected_ID)

MF_molten_pivot_ID <- t(pivot_wider(unique(MF_molten_selected_ID), names_from = L1, values_from = classicFisher))

colnames(MF_molten_pivot_ID) <- MF_molten_pivot_ID[1,]
MF_molten_pivot_ID <- MF_molten_pivot_ID[-c(1),]
MF_molten_pivot_ID <- as.data.frame(MF_molten_pivot_ID)


MF_molten_pivot_ID <- MF_molten_pivot_ID %>% 
  mutate(across(where(is.character), as.numeric))

MF_molten_pivot_ID <- MF_molten_pivot_ID[,colSums(is.na(MF_molten_pivot_ID)) == 14]

MF_molten_pivot_ID <- MF_molten_pivot_ID %>% 
  mutate_if(is.numeric, ~replace(., is.na(.), 1))

Go2Term <- MF_molten %>% 
  filter(variable == "Term") %>%
  select(c(GO.ID, value))

Go2Term <- unique(Go2Term)

x <- xx[colnames(MF_molten_pivot_ID)]
colnames(MF_molten_pivot_ID) <- as.character(map(x, Term))

MF_molten_term_log10 <- -log10(t(MF_molten_pivot_ID))
MF_molten_term_log10_ordered  <- MF_molten_term_log10[ order(rowMeans(MF_molten_term_log10), decreasing = T), ]

# Just for taking top .... for powerpoint
top10_MF_molten_term_log10_ordered <- MF_molten_term_log10_ordered[1:40,]
pheatmap(mat = top10_MF_molten_term_log10_ordered, fontsize_row = 10, main = "Unique significant terms", angle_col = 45, cluster_rows = FALSE, cluster_cols = FALSE, cellwidth = 14, cellheight = 10)



#pheatmap(mat = MF_molten_term_log10_ordered, fontsize_row = 8, main = "Unique significant terms", angle_col = 45, cluster_rows = FALSE, cluster_cols = FALSE, cellwidth = 14, cellheight = 10)

```


```{r, fig.width=10, fig.retina}
CC <- map(experiments_GO_analysis, 3)

titel = "-log 10 p-values Fisher Test on GO Cellular Component level"
show_GO_heatmap_experiments(level = CC, Titel = titel)
```


##  GO term analysis on all normal experiments, excluding replicates and starvation
```{r}
#take subset removing the starv, control, mutant and Gbeta2 (replicate)  
normal_experiments_sub <- all_data_dicty_roco4_corrected %>% 
  filter(condition != "starv") %>%
  filter(condition != "control") %>%
  filter(bait != "RasG-S17N") %>%
  filter(bait != "Gbeta2") %>%
  group_by(bait, condition) %>% 
  tidyr::unite(experiment, c(bait, condition), sep = "_") %>%
  mutate(experiment = str_replace(experiment, pattern = "_normal", replacement = ""))

experiments_GO_analysis_normal <- list()

universe_accessions_normal <- unique(normal_experiments_sub$uniprot_short)

# create new sub universe from total, filtering on the short uniprot ids in the current dataset
load(file = "UniverseGo.RData")
universeGO_normal <- universeGO[rownames(universeGO) %in% universe_accessions_normal,]

do_GO_analysis_on_experiments_normal <- function(my_data = normal_experiments_sub, my_experiment = experiment){

  print(my_experiment)
  
  # filter on z-score, do we need to do this? as we are scoring all proteins?
  uniprot_ids <- normal_experiments_sub %>% 
    filter(experiment == my_experiment) %>%
    filter(z_score_spectral > 2 | z_score_spectral < -2) %>%
    select(uniprot)
  
  # convert ids long uniprot to short accession
  experiment_accessions <- get_uniprot(uniprot_ids)
  print(length(experiment_accessions))
  
  #Do enrichment analysis, report all proteins above z-score threshold
  MF_GO_phylo <- go_enrichment_analysis(accessions = experiment_accessions, ontology = "MF", tableTopNodes = length(experiment_accessions), save_file = TRUE, show_fig = FALSE, bait_condition = my_experiment)
  
  BP_GO_phylo <- go_enrichment_analysis(accessions = experiment_accessions, ontology = "BP", tableTopNodes = length(experiment_accessions), save_file = TRUE, show_fig = FALSE, bait_condition = my_experiment)
  
  CC_GO_phylo <- go_enrichment_analysis(accessions = experiment_accessions, ontology = "CC", tableTopNodes = length(experiment_accessions), save_file = TRUE, show_fig = FALSE, bait_condition = my_experiment)

  GO_list <- list("MF" = MF_GO_phylo, "BP" = BP_GO_phylo, "CC" = CC_GO_phylo)
 
  return(GO_list)
}

# get the unique experiment names
experiments_normal <- unique(normal_experiments_sub$experiment)

# do go enrichment for each experiment, save results in list
for (experiment in experiments_normal){
   experiments_GO_analysis_normal[[experiment]] <- do_GO_analysis_on_experiments_normal(my_data = normal_experiments_sub, my_experiment = experiment)
}


```

## GO MF heatmap normal experiments
```{r, fig.width=10, fig.retina=2}
# get first list (MF) of each experiment
MF_normal <- map(experiments_GO_analysis_normal, 1)

titel = "-log 10 p-values Fisher Test on GO Molecular Function level"
show_GO_heatmap_experiments(level = MF_normal, Titel = titel, sign = 0.01)
```
## GO BP heatmap normal experiments
```{r, fig.width=24, fig.retina=2}
# get first list (MF) of each experiment
BP_normal <- map(experiments_GO_analysis_normal, 2)

titel = "-log 10 p-values Fisher Test on GO Molecular Function level"
show_GO_heatmap_experiments(level = BP_normal, Titel = titel, sign = 0.01)
```

## GO CC heatmap normal experiments
```{r, fig.width=9, fig.retina=2}
# get first list (MF) of each experiment
CC_normal <- map(experiments_GO_analysis_normal, 3)

titel = "-log 10 p-values Fisher Test on GO Molecular Function level"
show_GO_heatmap_experiments(level = CC_normal, Titel = titel, sign = 0.01)
```
## unique enriched GO terms all normal experiments, exlcuding replicates and starvation
```{r fig.width=10, fig.retina=1}
# Filter on terms enriched in only 1 bait
BP_normal <- map(experiments_GO_analysis_normal, 2)


get_unique_enriched_go <- function(GO_set){
  molten_GO_set <- melt(GO_set, id = c("GO.ID","classicFisher"))

# get GO ids, instead Terms
molten_GO_set_selected_ID <- molten_GO_set %>% 
  select(GO.ID, classicFisher, L1)

molten_GO_set_selected_ID <- unique(molten_GO_set_selected_ID)

molten_pivot_ID <- t(pivot_wider(unique(molten_GO_set_selected_ID), names_from = L1, values_from = classicFisher))

colnames(molten_pivot_ID) <- molten_pivot_ID[1,]
molten_pivot_ID <- molten_pivot_ID[-c(1),]
molten_pivot_ID <- as.data.frame(molten_pivot_ID)

molten_pivot_ID <- molten_pivot_ID %>% 
  mutate(across(where(is.character), as.numeric))

molten_pivot_ID <- molten_pivot_ID[,colSums(is.na(molten_pivot_ID)) == 14]

molten_pivot_ID <- molten_pivot_ID %>% 
  mutate_if(is.numeric, ~replace(., is.na(.), 1))

Go2Term <- molten_GO_set %>% 
  filter(variable == "Term") %>%
  select(c(GO.ID, value))

Go2Term <- unique(Go2Term)

x <- xx[colnames(molten_pivot_ID)]
colnames(molten_pivot_ID) <- as.character(map(x, Term))

molten_term_log10 <- -log10(t(molten_pivot_ID))
molten_term_log10_ordered  <- molten_term_log10[ order(rowMeans(molten_term_log10), decreasing = T), ]

# Just for taking top .... for powerpoint
#top10_molten_term_log10_ordered <- molten_term_log10_ordered[1:40,]
#pheatmap(mat = top10_molten_term_log10_ordered, fontsize_row = 10, main = "Unique significant terms", angle_col = 45, cluster_rows = FALSE, cluster_cols = FALSE, cellwidth = 14, cellheight = 10)

pheatmap(mat = molten_term_log10_ordered, fontsize_row = 8, main = "Unique significant terms", angle_col = 45, cluster_rows = FALSE, cluster_cols = FALSE, cellwidth = 14, cellheight = 10)
}

get_unique_enriched_go(BP_normal)

```

## Look for eat, drink or move Go terms
```{r}
# chemotaxis: BP; 0006935
grep("0006935", BP)
#integer(0)

# phagocytosis: BP; 0006909
grep("0006909", BP)
#integer(0)

# pinocytosis: BP; 0006907 or 0006908 or 1902536
grep("0006907", BP)
#[1] 3
grep("0006907", BP$Galpha1_normal$GO.ID)
#[1] 26
BP$Galpha1_normal[26,]
#        GO.ID        Term Annotated Significant Expected classicFisher
#26 GO:0006907 pinocytosis        28           4     0.78       0.00644
```



## Show overlapping peptides for a given bait selection

### Galpha2, Galpha4, Galpha8
```{r echo=FALSE, fig.height=5, fig.width=15, message=FALSE, warning=FALSE}
overlapping_ids <- show_overlapping_peptides_ROCO4_Background_corrected(my_dicty_data = all_data_dicty_roco4_corrected, bait1 = 'Galpha2', bait2 = 'Galpha4', bait3 = 'Galpha8', z_threshold = 2, scaled = TRUE, show_venn = TRUE)
accessions <- get_uniprot(overlapping_ids$Galpha2_Galpha4)
combine_GO(accessions)
```
### Overlap Galpha2 vs Galpha4 
```{r}
galpha2_galpha4_overlap <- get_uniprot(overlapping_ids$overlap_pairs$Galpha2...Galpha4)
galpha2_galpha4_overlap

# TODO, fix plotting function. Wrong experiment is shown!
#vis_testing <- filter_data(celltype = 'dicty', uniprot_in = galpha2_galpha4_overlap[1], experiment_bool = TRUE, normalized = TRUE)
#EDM_plot(my_data = vis_testing)

unique(all_data_dicty_roco4_corrected_grouped$long_id[all_data_dicty_roco4_corrected_grouped$uniprot_short %in% galpha2_galpha4_overlap])

```

### Overlap Galpha2 vs Galpha8
```{r}
galpha2_galpha8_overlap <- get_uniprot(overlapping_ids$overlap_pairs$Galpha2...Galpha8)
galpha2_galpha8_overlap

unique(all_data_dicty_roco4_corrected_grouped$long_id[all_data_dicty_roco4_corrected_grouped$uniprot_short %in% galpha2_galpha8_overlap])
```


### RasG, RasB and RasC
```{r echo=FALSE, fig.height=5, fig.width=15, message=FALSE, warning=FALSE}
overlapping_ids <- show_overlapping_peptides_ROCO4_Background_corrected(my_dicty_data = all_data_dicty_roco4_corrected, bait1 = 'RasB', bait2 = 'RasC', bait3 = 'RasG', z_threshold = 2, scaled = TRUE, show_venn = TRUE)
accessions <- get_uniprot(overlapping_ids$RasB_RasC)
combine_GO(accessions)
```
### Overlap RasB vs RasG 
```{r}
RasB_RasG_overlap <- get_uniprot(overlapping_ids$overlap_pairs$RasB...RasG)
RasB_RasG_overlap

unique(all_data_dicty_roco4_corrected_grouped$long_id[all_data_dicty_roco4_corrected_grouped$uniprot_short %in% RasB_RasG_overlap])
```


### Overlap RasB vs RasC 
```{r}
RasB_RasC_overlap <- get_uniprot(overlapping_ids$overlap_pairs$RasB...RasC)
RasB_RasC_overlap

unique(all_data_dicty_roco4_corrected_grouped$long_id[all_data_dicty_roco4_corrected_grouped$uniprot_short %in% RasB_RasC_overlap])
```

### Overlap RasC vs RasG
```{r}
RasC_RasG_overlap <- get_uniprot(overlapping_ids$overlap_pairs$RasC...RasG)
RasC_RasG_overlap

unique(all_data_dicty_roco4_corrected_grouped$long_id[all_data_dicty_roco4_corrected_grouped$uniprot_short %in% RasC_RasG_overlap])
```



### Galpha2 and Gbeta
```{r echo=FALSE, fig.height=5, fig.width=15, message=FALSE, warning=FALSE}
overlapping_ids <- show_overlapping_peptides_ROCO4_Background_corrected(my_dicty_data = all_data_dicty_roco4_corrected, bait1 = 'Galpha2', bait2 = 'Gbeta1', bait3 = 'Gbeta2', z_threshold = 2, scaled = TRUE, show_venn = TRUE)
accessions <- get_uniprot(overlapping_ids$Galpha2_Gbeta1)
combine_GO(accessions)
```

### Overlap Galpha2 vs Gbeta1 
```{r}
Galpha2_Gbeta1_overlap <- get_uniprot(overlapping_ids$overlap_pairs$Galpha2...Gbeta1)
Galpha2_Gbeta1_overlap

unique(all_data_dicty_roco4_corrected_grouped$long_id[all_data_dicty_roco4_corrected_grouped$uniprot_short %in% Galpha2_Gbeta1_overlap])
```

### Overlap Galpha2 vs Gbeta2
```{r}
Galpha2_Gbeta2_overlap <- get_uniprot(overlapping_ids$overlap_pairs$Galpha2...Gbeta2)
Galpha2_Gbeta2_overlap

unique(all_data_dicty_roco4_corrected_grouped$long_id[all_data_dicty_roco4_corrected_grouped$uniprot_short %in% Galpha2_Gbeta2_overlap])
```


### Rac1, Gbeta
```{r echo=FALSE, fig.height=5, fig.width=15, message=FALSE, warning=FALSE}
overlapping_ids <- show_overlapping_peptides_ROCO4_Background_corrected(my_dicty_data = all_data_dicty_roco4_corrected, bait1 = 'Rac1', bait2 = 'Gbeta1', bait3 = 'Gbeta2', z_threshold = 2, scaled = TRUE, show_venn = TRUE)
accessions <- get_uniprot(overlapping_ids$Rac1_Gbeta1)
combine_GO(accessions)
```

### overlap Rac1 vs Gbeta1
```{r}

Rac1_Gbeta1_overlap <- get_uniprot(overlapping_ids$overlap_pairs$Rac1...Gbeta1)
Rac1_Gbeta1_overlap

unique(all_data_dicty_roco4_corrected_grouped$long_id[all_data_dicty_roco4_corrected_grouped$uniprot_short %in% Rac1_Gbeta1_overlap])

```


### overlap Rac1 vs Gbeta2
```{r}

Rac1_Gbeta2_overlap <- get_uniprot(overlapping_ids$overlap_pairs$Rac1...Gbeta2)
Rac1_Gbeta2_overlap

unique(all_data_dicty_roco4_corrected_grouped$long_id[all_data_dicty_roco4_corrected_grouped$uniprot_short %in% Rac1_Gbeta2_overlap])

```




## GO Term analysis on overlapping peptides
```{r fig.height=6, fig.width=10}

#accessions <- get_uniprot(overlapping_ids$Galpha2_Galpha4)
#go_term_analysis(accessions)
#combine_GO(accessions)
```

## GO enichment analysis and phylogeny using Fisher exact test
```{r message=FALSE, warning=FALSE, echo=FALSE}
#get significant overlapping peptides
overlapping_ids <- show_overlapping_peptides_ROCO4_Background_corrected(my_dicty_data = all_data_dicty, bait1 = 'Galpha2', bait2 = 'Galpha4', bait3 = 'Galpha8', z_threshold = 1, scaled = TRUE, show_venn = FALSE)
#convert long uniprot id to short id, selecting part of the overlap
accessions <- get_uniprot(overlapping_ids$Galpha2_Galpha4)

```

```{r message=FALSE, warning=FALSE, echo=FALSE}
MF_GO_phylo <- go_enrichment_analysis(accessions = accessions, ontology = "MF", tableTopNodes = 10, figNodeSize = 5, figSigNodes = 5, save_file = TRUE, bait_condition = "Galpha2_Galpha4")
```


```{r message=FALSE, warning=FALSE, echo=FALSE}
BP_GO_phylo <- go_enrichment_analysis(accessions = accessions, ontology = "BP", tableTopNodes = 10, figNodeSize = 5, figSigNodes = 5, save_file = TRUE, bait_condition = "Galpha2_Galpha4")
BP_GO_phylo
```


```{r message=FALSE, warning=FALSE, echo=FALSE}
CC_GO_phylo <- go_enrichment_analysis(accessions = accessions, ontology = "CC", tableTopNodes = 10, figNodeSize = 5, figSigNodes = 5, save_file = TRUE, bait_condition = "Galpha2_Galpha4")
```



## KEGG pathway enrichment analysis
```{r}
# prepare annotation database
hub <- AnnotationHub()
q <- query(hub, "Dictyostelium discoideum")
id <- q$ah_id[length(q)]
dicty <- hub[[id]]
```


```{r}
# select uniprot id's based on experiment and threshold
df <- all_data_dicty %>%
  filter(bait == "Galpha2" & condition == "normal" & z_score_spectral > 0 | bait == "Galpha2" & condition == "normal" & z_score_spectral < -0) %>%
  select(c(z_score_spectral, uniprot_short))
```


```{r}
## KEGG enrichment analysis, map all genes? color by z-score?
dicty_kegg <- search_kegg_organism('ddi', by='kegg_code')

#convert uniprot to kegg ud
eg2np <- bitr_kegg(df$uniprot_short, fromType='uniprot', toType='kegg', organism='ddi')

kk <- enrichKEGG(gene         = eg2np$kegg,
                 organism     = 'ddi',
                 pvalueCutoff = 0.05,
                 keyType = "kegg")
head(kk)
```


## KEGG Module enrichment analysis
```{r}
## KEGG module over-representation analysis
mkk <- enrichMKEGG(gene = eg2np$kegg,
                   organism = 'ddi',
                   pvalueCutoff = 1,
                   qvalueCutoff = 1,
                   keyType = "kegg")
head(mkk)
```


## Visualize KEGG pathway
```{r}
browseKEGG(kk, 'ddi01200')

# chemotaxis
# no map: 02030

# Endocytosis
browseKEGG(kk, 'ddi02040')

# Phagocytosis
browseKEGG(kk, 'ddi04145')
```

```{r}
library("pathview")

genes <- kk@result$geneID[1]
pathway <- kk@result$ID[1]

genes <- unlist(strsplit(genes, split = "/"))

ddi01200 <- pathview(gene.data  = genes,
                     pathway.id = pathway,
                     species    = "ddi", 
                     gene.idtype = "KEGG"
                    )


```


# Discussion


# Conclusion


# Supplements

## number of unique proteins per organism on the raw data
```{r, echo=FALSE, results=FALSE}
# show the counts per organism after removal of other species, see supplement for counts before removal
knitr::kable(all_data_non_corrected %>% group_by(Organism) %>% summarise(Unique_Proteins = n_distinct(uniprot)), caption = "Unique proteins per organism")
```

## Uniq proteins per experiment non corrected data
```{r}
# show uniq peptides for each experiments as bait can be part of multiple experiments, this is in the non filtered (on organism and GST tag) and not background corrected proteins

uniq_uniprot_per_experiment <- all_data_non_corrected %>% 
  filter(spectral_count > 0) %>%
  group_by(bait, condition) %>%
  dplyr::summarise(unique_proteins = n_distinct(uniprot))

knitr::kable(uniq_uniprot_per_experiment, caption = "Unique proteins per experiment on raw data")
```



## boxplot experiment absolute count

```{r}
# scaling function to deal with 0 or negative values, needs scale library
asinh_trans <- function(){
  trans_new(name = 'asinh', transform = function(x) asinh(x), 
            inverse = function(x) sinh(x))
}

sqrt_trans <- function(){
  trans_new(name = 'S_sqrt', transform = function(x) {sign(x)*sqrt(abs(x))},
            inverse = function(x) {x^2*sign(x)})
}

log_trans <- function(){
   trans_new(name = 'log_negative', transform = function(x) {sign(x)*log(abs(x), 10)},
            inverse = function(x) {10^x*sign(x)})
}

# set using: p + scale_y_continuous(trans="asinh") +
```


## Boxplot combined spectral count for experiment
```{r}
my_data <- all_data_dicty %>% 
    filter(spectral_count > 0) %>% # remove 0 counts, peptide not there
  group_by(bait, condition) %>% 
    tidyr::unite(bait_condition, c(bait, condition), sep = "_")

p <- ggplot(my_data, 
            aes(x = bait_condition, 
                y = spectral_count)) + 
  geom_boxplot(outlier.colour = "black") + 
  scale_y_continuous(trans="asinh", n.breaks = 6) +
  labs(title = 'Boxplot spectral count vs experiments') +
  xlab("Experiments") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p
```

## Violin plot of the spectral counts to show distribution + quantiles
```{r}
my_data <- all_data_dicty %>% 
  filter(spectral_count > 0) %>% # remove 0 counts, peptide not there
  group_by(bait, condition) %>% 
    tidyr::unite(bait_condition, c(bait, condition), sep = "_")

p <- ggplot(my_data, aes(x = bait_condition, y = spectral_count)) + 
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75)) + 
  scale_y_continuous(trans="asinh", n.breaks = 6) +
  labs(title = 'spectral count vs experiments') + 
  xlab("Experiments") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

```


## z-score normalized violin count vs experiment
```{r}
my_data <-all_data_dicty %>% 
  group_by(bait, condition) %>% 
    tidyr::unite(bait_condition, c(bait, condition), sep = "_")
my_data$bait_condition <- as.factor(my_data$bait_condition)

p <- ggplot(my_data, aes(x = bait_condition, y = z_score_spectral)) +
 geom_violin(draw_quantiles = c(0.25, 0.5, 0.75)) + 
  scale_y_continuous(trans="asinh") +
  labs(title = 'z-scaled spectral counts vs experiments') + 
  xlab("Experiments") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
p

```


## z-score normalized boxplot count vs experiment
```{r}
my_data <-all_data_dicty %>% 
  group_by(bait, condition) %>% 
    tidyr::unite(bait_condition, c(bait, condition), sep = "_")
my_data$bait_condition <- as.factor(my_data$bait_condition)

p <- ggplot(my_data, aes(x = bait_condition, y = z_score_spectral)) + 
  geom_boxplot() + # outliers are hidden
  labs(title = 'Z-scaled spectral count vs experiments') + 
  xlab("Experiments") +
  scale_y_continuous(trans="asinh") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

```


## Unique proteins per experiment
```{r}
uniprotID_uniq_protein_above_threshold <- all_data_dicty_roco4_corrected %>%
  ungroup() %>%
  filter(z_score_spectral > 2 | z_score_spectral < -2) %>%
  dplyr::count(uniprot) %>%
  filter(n == 1)

# 114 proteins above 2sd are unique over the experiments
  
uniq_proteins_above_threshold <- all_data_dicty_roco4_corrected %>%
  filter(z_score_spectral > 2 | z_score_spectral < -2) %>%
  group_by(bait, condition) %>%
  tidyr::unite(bait_condition, c(bait, condition), sep = "_") %>%
  filter(uniprot %in% uniprotID_uniq_protein_above_threshold$uniprot)

#table(uniq_protein_above_threshold$bait_condition)
barplot(table(uniq_proteins_above_threshold$bait_condition), las=2, cex.names = 0.6, main = "Number of unique proteins per experiment")

```

```{r}
#TODO: annotate the unique proteins per experiment

Galpa2_normal_uniq <- uniq_proteins_above_threshold$Gene.ontology..biological.process.[uniq_proteins_above_threshold$bait_condition == 'Galpha2_normal']
counted <- plyr::count(unlist(strsplit(Galpa2_normal_uniq, split = "; ")))
plotWordcloud(counted$x[counted$x != "NA"], counted$freq[counted$x != "NA"], min.freq = 1,
              max.words=200, random.order=FALSE, rot.per=0.35, 
              colors=brewer.pal(8, "Dark2"))

```

```{r}
Galpa2_starv_uniq <- uniq_proteins_above_threshold$Gene.ontology..biological.process.[uniq_proteins_above_threshold$bait_condition == 'RasG_normal']
counted <- plyr::count(unlist(strsplit(Galpa2_starv_uniq, split = "; ")))
plotWordcloud(counted$x[counted$x != "NA"], counted$freq[counted$x != "NA"], min.freq = 1,
              max.words=200, random.order=FALSE, rot.per=0.35, 
              colors=brewer.pal(8, "Dark2"))

```

## Experiment correlation on Roco4 background corrected spectral count data dicty vs NON dicty
```{r}
# Prepare all NON dicty protein dataframe for correlation analysis.

roco4_uniprot_NON_dicty <- all_data_non_dicty %>% 
    filter(bait=='Roco4') %>% 
    dplyr::select(uniprot, z_score_spectral) %>%
    filter(z_score_spectral > 2 | z_score_spectral < -2)

cor_experiment_roco4_corrected_selected_NON_dicty <- all_data_non_dicty %>% 
  filter(!(uniprot %in% roco4_uniprot_NON_dicty$uniprot)) %>%
  filter(!bait == "Roco4")

cor_experiment_NON_dicty_Roco4_corrected <- cor_experiment_fun(cor_experiment_roco4_corrected_selected_NON_dicty)
```


```{r}
pivoted_experiment_t_dicty <- t(cor_experiment_roco4_corrected_dicty)
res_t_pivoted_experiment_dicty <- cor(pivoted_experiment_t_dicty)

pivoted_experiment_t_NON_dicty <- t(cor_experiment_NON_dicty_Roco4_corrected)
res_t_pivoted_experiment_NON_dicty <- cor(pivoted_experiment_t_NON_dicty)
```


```{r}
par(mfrow=c(1,2))
heatmap(x = res_t_pivoted_experiment_dicty, symm = TRUE, main = "Roco4 corrected spectral counts dicty")
heatmap(x = res_t_pivoted_experiment_NON_dicty, symm = TRUE, main = "Roco4 corrected spectral counts NON dicty")
```


## Correlation on peptide z_score based on peptide having z-score above or below 2*sd for every experiment 
```{r}

## All uniprots correlation on spectral count data 
#res_experiment <- cor(cor_experiment_NON_dicty_Roco4_corrected)
#heatmap(x = res_experiment, symm = TRUE)


#select all proteins that have z-score +2 or -2 over all conditions
#cor_experiment_roco4_corrected_dicty
#pivoted_experiment_t_roco4_corrected_dicty
#res_t_pivoted_experiment_roco4_corrected_dicty


#all_data_non_dicty %>%
#    group_by(bait, condition) %>%
#    dplyr::select(uniprot, bait, condition, spectral_count) 


#cor_experiment <- all_data_non_dicty %>% 
#  group_by(bait, condition) %>% # create combinations of bait and condition
#  dplyr::select(uniprot, bait, condition, z_score_spectral) %>% # which columns are we going to use
#  dplyr::mutate(row = row_number()) %>%  # add column with incremental row number
#  tidyr::pivot_wider(names_from = uniprot, values_from = z_score_spectral, values_fill = 0) %>% # increase number of columns, get names from uniprot column and values from spectral_count
#  dplyr::select(-row) %>% # remove previously created row index column
#  #summarise_all(list(sum = sum)) %>% # sum the number of spectral counts for same uniprot ids within a group
#  tidyr::unite(bait_condition, c(bait, condition), sep = "_")  # create new column for the experiments
#  #tibble::column_to_rownames(var = "bait_condition") # rownames are removed when subsetting, add rownames again, use column bait_condition for naming
  

#Z_score_deviated_subset <- cor_experiment[, apply(cor_experiment, 2, function(x) sum(x > 2 | x < -2) == length(rownames(cor_experiment)))]

#pheatmap(Z_score_deviated_subset, scale = "row", fontsize_row = 6)
#Error in seq.default(-m, m, length.out = n + 1) : 'from' must be a finite number
```



### Percentage of variance explained by each principal component from the filtered, roco4 corrected data
```{r}
screeplot(wdbc.pr_roco4_corrected, type = "l", npcs = 15, main = "Screeplot of the first 15 PCs")
abline(h = 1, col="red", lty=5)
legend("topright", legend=c("Eigenvalue = 1"),
       col=c("red"), lty=5, cex=0.6)
cumpro <- cumsum(wdbc.pr_roco4_corrected$sdev^2 / sum(wdbc.pr_roco4_corrected$sdev^2))
plot(cumpro[0:15], xlab = "PC #", ylab = "Amount of explained variance", main = "Cumulative variance plot")
#abline(v = 6, col="blue", lty=5)
#abline(h = 0.88759, col="blue", lty=5)
#legend("topleft", legend=c("Cut-off @ PC6"),col=c("blue"), lty=5, cex=0.6)
```


## PCA Experiment on z_score_spectral not background corrected
```{r}
my_data <- all_data_dicty %>% 
  group_by(bait, condition) %>% 
  tidyr::unite(bait_condition, c(bait, condition), sep = "_")

pca_experiment <- my_data %>% 
  dplyr::select(uniprot, bait_condition, z_score_spectral) %>%
  group_by(bait_condition) %>%
  pivot_wider(names_from = uniprot, values_from = z_score_spectral, values_fill = 0) %>%
  summarise_all(list(sum = sum)) %>%
  tibble::remove_rownames() %>%
  tibble::column_to_rownames(var = "bait_condition") 

wdbc.pr <- prcomp(pca_experiment)
summary(wdbc.pr)
```


### 2D PCA-plot
```{r}
#plot(wdbc.pr$x[,1],wdbc.pr$x[,2], xlab="PC1 (47.4%)", ylab = "PC2 (20.3%)", main = "PC1 / PC2 - plot")

fviz_pca_ind(wdbc.pr, geom = c("point", "text"), pointshape = 21, 
             pointsize = 2, 
             fill.ind = rownames(pca_experiment), 
             col.ind = "black", 
             palette = "ucscgb", 
            # addEllipses = TRUE,
             label = "all",
             col.var = "black",
             repel = TRUE,
             legend.title = "Experiments") +
  ggtitle("2D PCA-plot") +
  theme(plot.title = element_text(hjust = 0.5))
```


## Igraph network plot
```{r}

my_data <- all_data_dicty_roco4_corrected %>% 
  group_by(bait, condition) %>% 
  tidyr::unite(bait_condition, c(bait, condition), sep = "_")

x <- my_data %>% 
  separate(uniprot, c("a", "b", "c", "protid", "genid", "source"), extra = "merge", fill = "left", sep = '[_|]')
x <- x %>% 
  dplyr::select(-one_of(c("a", "b", "c")))

# resulting in 17k+ interactions, hairball!, need to filter on z-score and minimal count
new_x <- x %>% 
  filter(z_score_spectral > 2 & spectral_count > 15 | z_score_spectral < -2 & spectral_count > 15)

nodes <- as.data.frame(unique(new_x$bait_condition))
nodes$shape = 'triangle'
colnames(nodes) <- c('id', 'shape')

nodes <- nodes %>% 
  add_row(id = unique(new_x$genid), shape = 'circle')

#nodes <- nodes %>% add_row(id = unique(new_x$genid))
nodes$label <- nodes$id

my_edges <- data.frame(new_x$bait_condition, new_x$genid, new_x$z_score_spectral)
colnames(my_edges) <- c('from', 'to', 'value')

graph <- graph_from_data_frame(my_edges, directed = FALSE)

visNetwork(nodes = nodes, edges = my_edges) %>%
  visOptions(highlightNearest = list(enabled = TRUE, algorithm = "hierarchical", 
   degree = list(from = 1, to = 1)), nodesIdSelection = TRUE) %>%
  visPhysics(stabilization = FALSE) %>%
  visLayout(improvedLayout = TRUE)
```


